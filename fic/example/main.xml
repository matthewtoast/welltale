<!-- 
  Voice definitions for text-to-speech:
  Define custom voices that can be referenced later using voice="id" attributes.
  These descriptions help the TTS system generate appropriate vocal characteristics.
-->
<voice id="narrator" description="warm, friendly storyteller voice" />
<voice id="goblin" description="raspy, menacing voice" />

<!-- 
  Macro system for content transformation:
  This macro automatically transforms all <room> elements by:
  1. Renaming them to <div> with a CSS class
  2. Adding atmospheric sound effects and timing
  Macros provide a powerful way to standardize and enhance content.
-->
<macro match="room">
  <rename to="div" />
  <set attr="class" value="room-description" />
  <prepend>
    <sound prompt="footsteps echoing in stone corridors" duration="2000" />
    <sleep duration="1000" />
  </prepend>
</macro>

<!-- 
  External data loading:
  Loads structured game data from YAML files, making it accessible
  as variables throughout the story (rooms, items, classes, etc.)
-->
<data src="data.yml" />

<!-- 
  Global variable declarations:
  These persist throughout the entire story session.
  Note: inventory uses {$ [] $} syntax to create a proper JavaScript array
  rather than type="array" which doesn't work as expected.
-->
<var name="playerName" value="" />
<var name="playerClass" value="" />
<var name="health" value="0" type="number" />
<var name="strength" value="0" type="number" />
<var name="magic" value="0" type="number" />
<var name="inventory" value="{$ [] $}" />
<var name="currentRoom" value="entry" />
<var name="gameComplete" value="false" type="boolean" />

<!-- 
  Story introduction (first-time play only):
  <intro> blocks execute only on session.turn === 1 when NOT resuming.
  After intro completes, execution returns to the <origin> tag.
  All content here becomes audio - background music plays while text is spoken.
-->
<intro>
  <music duration="8000" fadeAt="6000" background="true">
    mysterious dungeon ambience with distant echoes
  </music>
  <sleep duration="2000" />
  <p>
    Welcome to {{title}}, by {{author}}.
  </p>
  <p>
    You stand before the entrance to an ancient dungeon.
    Legend speaks of great treasures hidden within...
  </p>
  <jump to="character-creation" />
</intro>

<!-- 
  Resume block (returning players only):
  <resume> blocks execute only when session.resume === true.
  This allows different content for players continuing a saved story.
  After resume completes, execution returns to the <origin> tag.
-->
  <p>
    Welcome back, {{playerName}} the {{playerClass}}.
  </p>
  <if cond="health <= 0">
    <p>You died in your last adventure. Starting fresh...</p>
    <jump to="character-creation" />
  </if>
  <p>
    You are in the {{rooms[currentRoom].name}} with {{health}} health remaining.
  </p>
  <jump to="main-game-loop" />
</resume>

<!-- 
  Story origin (main entry point):
  <origin> defines the primary starting point for story execution.
  If no origin exists, the root node is used. This is where normal
  gameplay begins after intro/resume content completes.
-->
<origin id="character-creation">
  <room>
    <p>
      Before entering the dungeon, tell me your name.
    </p>
    
    <!-- 
      String input demonstration:
      1. Use <input> to capture user input and store it in a variable
      2. Define the variable using dot notation (playerName.description, playerName.default)
      3. Reference the captured value using {{}} Handlebars-style template syntax
      
      Note: Input types can be string, number, boolean, int, array<type>, or enum (pipe-separated)
    -->
    <input 
      playerName.description="Your character's name"
      playerName.default="Adventurer" />
    
    <p>
      Greetings, {{playerName}}! What is your character class? You can choose warrior, mage, or rogue.
    </p>
    
    <!-- 
      Enum input with type constraints:
      The .type attribute supports many formats:
      - "option1|option2|option3" for enums (with fuzzy matching)
      - "string", "number", "boolean", "int" for basic types
      - "array<string>", "number[]" for arrays
      This example uses pipe-separated enum validation.
    -->
    <input
      playerClass.type="warrior|mage|rogue"
      playerClass.description="Your character class" />
    
    <!-- 
      JavaScript code execution:
      Use <code> to run JavaScript that can access game data and set variables.
      This code looks up class stats from the YAML data and assigns them.
    -->
    <code>
      const classData = classes[playerClass];
      health = classData.health;
      strength = classData.strength;
      magic = classData.magic;
    </code>
    
    <!-- 
      Mixed interpolation syntax demonstration:
      Evaluation order is: {{}} → {$ $} → [variations] → {% %}
      - {{}} for simple variable/object access (supports {{rooms[currentRoom].name}})
      - {$ $} for JavaScript expressions and calculations
      Each syntax can operate on text generated by previous ones.
    -->
    <p>
      You are now a {{classes[playerClass].name}} with {$ health $} health,
      {$ strength $} strength, and {$ magic $} magic.
    </p>
    
    <!-- 
      Conditional text with <when> tags:
      These allow inline conditional content based on variable values.
      Unlike <if>, <when> tags can be embedded within paragraphs.
      Remember: ALL text content becomes audio - this will be spoken aloud!
    -->
    <p>
      <when cond="strength > 5">You flex your muscles confidently.</when>
      <when cond="magic > 5">Arcane energy crackles around your fingers.</when>
      <when cond="strength <= 5 && magic <= 5">You move with nimble grace.</when>
    </p>
  </room>
  
  <jump to="main-game-loop" />
</origin>

<!-- Main game loop with room exploration -->
<sec id="main-game-loop">
  <room>
    <p>
      You are in the {{rooms[currentRoom].name}}.
      {{rooms[currentRoom].description}}
    </p>
    
    <!-- 
      Complex expression demonstration:
      Shows how to combine simple {{}} template variables with {$ $} JavaScript
      expressions for conditional logic and array manipulation.
      This status display will be read aloud to the player.
    -->
    <p>
      Health: {{health}} | Items: {$ inventory.length > 0 ? inventory.join(", ") : "none" $}
    </p>
    
    <!-- 
      Flow control with <if> and <yield>:
      - <if> tags control conditional execution based on variable values
      - <yield> jumps to reusable <block> sections defined elsewhere
      - This creates a modular room system where each room's logic is separate
    -->
    <if cond='currentRoom === "entry"'>
      <yield target="entry-hall-actions" />
    </if>
    <if cond='currentRoom === "armory"'>
      <yield target="armory-actions" />
    </if>
    <if cond='currentRoom === "vault"'>
      <yield target="vault-actions" />
    </if>
  </room>
</sec>

<!-- Entry Hall - Logic puzzle and basic exploration -->
<block id="entry-hall-actions">
  <p>
    Ancient runes cover the walls. There's a door to the north marked "ARMORY"
    and another to the east marked "VAULT". A strange glowing door to the west
    has runes that seem to shift and change.
  </p>
  
  <!-- 
    AI-generated content with {% %} liquid syntax:
    This syntax sends prompts to an LLM to generate dynamic text
    that changes each time the story is played. Generated text is spoken aloud.
  -->
  <p>
    {% Describe the mysterious atmosphere of this ancient dungeon entry hall %}
  </p>
  
  <!-- 
    Interactive game loop with AI text analysis:
    This demonstrates how to use AI to parse and understand player input,
    making the story more responsive to natural language commands.
    All AI responses and game feedback will be spoken as audio.
  -->
  <var name="playerAction" value="" />
  <while cond="!gameComplete">
    <input 
      playerAction.description="What do you do? (examine runes, go north, go east, try west door, or cast spell)" />
    
    <!-- 
      AI intent classification with <llm:tag>:
      This analyzes the player's text input and categorizes it into
      predefined intent types, enabling natural language interaction
    -->
    <llm:tag
      key="actionType"
      examine="player wants to examine or look at something"
      move="player wants to move or go somewhere"
      interact="player wants to interact with or use something"
      cast="player wants to cast a spell or use magic"
    >{{playerAction}}</llm:tag>
    
    <!-- 
      Structured data extraction with <llm:parse>:
      Based on the classified intent, we extract specific information
      from the player's input to understand what they want to examine
    -->
    <if cond='includes(actionType, "examine")'>
      <llm:parse 
        key="examineResult"
        object.description="What object is the player examining?"
        object.type="runes|door|room"
      >{{playerAction}}</llm:parse>
      
      <if cond='examineResult.object === "runes"'>
        <p>The runes glow faintly. You can make out the word "{{puzzles.rune_door.solution}}" among the symbols.</p>
        <set var="hasRuneKnowledge" value="true" />
      </if>
    </if>
    
    <if cond='includes(actionType, "move")'>
      <llm:parse
        key="movement"
        direction.description="Which direction does the player want to go?"
        direction.type="north|east|west|south"
      >{{playerAction}}</llm:parse>
      
      <if cond='movement.direction === "north"'>
        <set var="currentRoom" value="armory" />
        <break />
      </if>
      <if cond='movement.direction === "east"'>
        <set var="currentRoom" value="vault" />
        <break />
      </if>
      <if cond='movement.direction === "west"'>
        <if cond="hasRuneKnowledge">
          <p>You speak the word "LIGHT" and the door opens, revealing a healing potion!</p>
          <code>inventory.push("healing_potion");</code>
        </if>
        <if cond="!hasRuneKnowledge">
          <p>The door remains sealed. Perhaps you need to understand the runes first.</p>
        </if>
      </if>
    </if>
    
    <if cond='includes(actionType, "cast") && magic > 5'>
      <p>Your spell illuminates the room, making the runes easier to read!</p>
      <set var="hasRuneKnowledge" value="true" />
    </if>
    <if cond='includes(actionType, "cast") && magic <= 5'>
      <p>You don't have enough magical power for that.</p>
    </if>
  </while>
  
  <jump to="main-game-loop" />
</block>

<!-- Armory - Combat encounter -->
<block id="armory-actions">
  <p>
    Dust-covered weapon racks line the walls. A goblin guard blocks your path!
  </p>
  
  <!-- 
    Modular code organization with <include>:
    References reusable content blocks defined in other files.
    This keeps complex systems like combat separate and maintainable.
  -->
  <include id="goblin-combat" />
  
  <!-- 
    Post-combat logic with conditional execution based on player survival
  -->
  <if cond="health > 0">
    <p>You search the armory and find an enchanted blade!</p>
    <code>inventory.push("magic_sword");</code>
    
    <!-- 
      Variable scoping with <scope>:
      Variables declared inside <scope> tags don't persist outside.
      This is useful for temporary calculations or one-time values.
    -->
    <scope>
      <var name="searchTime" value="{$ randInt(5, 15) $}" />
      <p>After {$ searchTime $} minutes of searching, you also find a hidden passage!</p>
    </scope>
    
    <p>Where do you go next?</p>
    <input direction.type="entry|vault" direction.description="Which room?" />
    <set var="currentRoom" value="{{direction}}" />
  </if>
  
  <jump to="main-game-loop" />
</block>

<!-- Vault - Final challenge with multiple endings -->
<block id="vault-actions">
  <p>
    The treasure vault! Golden coins and precious gems glitter in the torchlight.
    But something seems wrong...
  </p>
  
  <!-- 
    AI scoring system with <llm:score>:
    This analyzes player input across multiple dimensions, giving numeric scores
    that can be used to influence story outcomes in sophisticated ways
  -->
  <var name="approach" value="" />
  <input approach.description="How do you approach the treasure? (carefully, quickly, magically)" />
  
  <llm:score
    key="approachScore"
    caution="How cautious is this approach?"
    aggression="How aggressive is this approach?"
    wisdom="How wise is this approach?"
  >{{approach}}</llm:score>
  
  <!-- 
    Structured content generation with <llm:generate>:
    Creates complex, multi-field data structures based on context.
    The AI generates appropriate values for each defined field,
    allowing for rich, dynamic storytelling that adapts to player choices.
    The generated outcome text will be read aloud to the player.
  -->
  <llm:generate
    key="vaultResponse"
    situation.description="The player's approach to the treasure"
    situation.value="{{approach}}"
    danger_level.description="How dangerous the situation becomes"
    danger_level.type="low|medium|high"
    outcome.description="What happens to the player"
    outcome.type="success|partial_success|failure"
  >
    A player approaches a trapped treasure vault. Their approach is: {{approach}}.
    The vault contains magical traps that respond to the intruder's intentions.
    Generate an appropriate outcome based on their approach.
  </llm:generate>
  
  <p>{{vaultResponse.outcome}}</p>
  
  <!-- 
    Branching narrative based on AI-generated outcomes:
    The story adapts dynamically based on the AI's assessment,
    creating unique experiences for different player approaches
  -->
  <if cond='vaultResponse.outcome === "success"'>
    <p>You successfully claim the greatest treasure: the Skeleton Key!</p>
    <code>inventory.push("skeleton_key");</code>
    <set var="gameComplete" value="true" />
    <jump to="victory-ending" />
  </if>
  
  <if cond='vaultResponse.outcome === "partial_success"'>
    <p>You grab some treasure but trigger a trap!</p>
    <set var="health" value="{$ Math.max(1, health - 20) $}" />
    <code>inventory.push("ancient_tome");</code>
    <jump to="main-game-loop" />
  </if>
  
  <if cond='vaultResponse.outcome === "failure"'>
    <p>The trap activates! You barely escape with your life.</p>
    <set var="health" value="{$ Math.max(1, health - 30) $}" />
    <jump to="main-game-loop" />
  </if>
</block>

<!-- 
  Story outro (completion):
  <outro> blocks execute when the story reaches its natural end.
  They only process when in outro context, triggered automatically
  when story loops are exhausted. Provides closure before story-end.
-->
<outro id="victory-ending">
  <music duration="5000" background="true">
    triumphant adventure completion music
  </music>
  <p>
    Congratulations, {{playerName}}! You have conquered the Enchanted Vault!
  </p>
  <p>
    Your final inventory: {$ inventory.map(item => items[item]?.name || item).join(", ") $}
  </p>
  <p>
    Thank you for playing {{title}}!
  </p>
</outro>